---
title: "[Data Structure] C++로 구현한 더블 링크드 리스트"
date: '2024-11-02'
---
## 더블 링크드 리스트 - 앞쪽삽입 / 끝쪽삽입 / 특정값 삭제 # 기능 구현
```cpp
#pragma once
#include <iostream>
// Node Class
class Node {
	friend class LinkedList; // LinkedList가 Node의 멤버 변수에 접근 허용

private:
	int data;
	Node* next;
	Node* pre; // Double LinkedList에 추가된 멤버 변수

public:
	Node(int data) : data(data), next(nullptr), pre(nullptr) {}
};

//
class LinkedList {
private:
	Node* head; // 첫번째 노드
	Node* tail; // 마지막 노드

public:
	LinkedList() :head(nullptr), tail(nullptr) {}
	~LinkedList(); // 메모리 관리를 위해

	// func
	void InsertFront(int data);
	void InsertBack(int data);
	void Delete(int data);
	void Display() const;
};

LinkedList::~LinkedList() {
	Node* curr = head;
	while (curr) {
		Node* tmp = curr->next; // 이렇듯 Node 변수에 접근하려면 friend 선언이 되어있어야 한다.
		delete curr;
		curr = tmp;
	}
}

void LinkedList::InsertFront(int data) {
	Node* newNode = new Node(data);
	newNode->next = head;

	if (head != nullptr) {
		head->pre = newNode;
	}
	else {
		tail = newNode;
	}
	head = newNode;
}

void LinkedList::InsertBack(int data) {
	Node* newNode = new Node(data);
	newNode->pre = tail;
	
	if (tail != nullptr) {
		tail->next = newNode;
	}
	else {
		head = newNode;
	}
	tail = newNode;
}

void LinkedList::Delete(int data) {
	Node* curr = head;

	while (curr) {
		if (curr->data == data) {
			if (curr->pre) {
				curr->pre->next = curr->next;
			}
			else {
				head = curr->next;
			}

			if (curr->next) {
				curr->next->pre = curr->pre; 
			}
			else {
				tail = curr->pre;
			}

			delete curr;
			return;
		}
		curr = curr->next;
	}
}

void LinkedList::Display() const {
	Node* curr = head;
	while (curr) {
		std::cout << curr->data << " ";
		curr = curr->next;
	}
	std::cout << "\n";
}

int main() {
	std::ios::sync_with_stdio(false);
	LinkedList linkedList = LinkedList();

	linkedList.InsertFront(1);
	linkedList.InsertFront(2);
	linkedList.InsertFront(3);
	linkedList.InsertBack(4);

	linkedList.Display();

	linkedList.Delete(2);

	linkedList.Display();

	return 0;
}
```